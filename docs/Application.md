## Application description

This is scallable simple Twitter LIKE API which offers writing and reading 
messages based on tags or timeline filters. 
To query this API you must use JSON format, same format is used in responses. 

Check `docs/API.md` for supported actions and `api_tests/json` for JSON samples



## Users

The application supports two type of users:

1) All users - they are eligible to read messages and filter them on tags but for 
such users there is limitation that only 100 last messages can be read (let's 
say for security reasons)

2) Authorized users - they have to authorize, obtain auth token and with 
   this token they can perform the following additional actions:

- filter based on time (time_from and time_to headers, user status = 'a')
- they can write new messages (user status = 'u')
- return unlimited messages (both status 'u' and 'a')



## Application internals

### WARNING 1
This is only a backend engine, there is no frontend part which would be responsible 
for user interface. In order to interact with this engine you need some kind of http/api tool like 
httpie/postman/web browser web tools, etc

### WARNING 2
Code is not optimal here and libs and techniques in general. That was written for 
presentation purposes so code quality may not be good as there were no additional linters used, 
no code reviews and deeper considerations.

### Libs and principles
This is compatibile with `go modules` app (see files `go.mod` and `go.sum`) hence it should be 
easier to deploy in non standard locations (let's say without proper go env configurations). 

This application is written in Go with `gorilla/mux` lib and uses external DB (cockroachdb) 
to store it's data.

To communicate with cockroachdb it's used standard `sql/database` lib for pgsql as 
cockroachdb is compatibile at driver level.

For logging purposes there I used `github.com/rs/zerolog` lib

The application is written in `Dependency Injection` principals - especially `database` package, 
thus for testing purposes (unit) we need only reimplement `Database` interface with 
testing things and that's it.

For testing purposes I'm using `testify` lib

## Swagger version

In first version I was testing go-swagger for code generation (look at 
swagger_version/ directory). Swagger version was mostly autogenerated, 
however, `swagger.(yaml|json)` needs to be very well defined which is 
challenging and go-swagger implementation of some things may be problematic 
at the moment. 

Despite it's pros (autogenerated docs/clients/servers) I dropped it as 
go-swagger makes things more complicated at the moment I would say (definitely 
I would need more time to deepdive into it)